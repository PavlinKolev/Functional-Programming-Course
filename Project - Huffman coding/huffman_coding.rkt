#lang racket

(define (1+ a) (+ a 1))

;removes all elements from llist that are equal to elem, but return the reversed list
(define (remove elem llist cond?)
    (define (remove_help elem llist res)
        (if (null? llist) res
            (if (cond? (car llist) elem) (remove_help elem (cdr llist) res)
                (remove_help elem (cdr llist) (cons (car llist) res))
            )
        )
    )
    (remove_help elem llist '())
)


(define (remove_at llist pos)
    (define (helper llist pos result)
        (cond((null? llist) (error "Index out of range."))
             ((= pos 0) (append result (cdr llist)))
             (else (helper (cdr llist) (- pos 1) (append result (list (car llist)))))
        )
    )
    (helper llist pos '())
)

;creates the pair (elem.count), which represent how many times elem is met in llist
(define (pair llist elem result)
    (let ((incr_count (cons elem (1+ (cdr result))))
         )
        (cond ((null? llist) result)
              ((= (car llist) elem) (pair (cdr llist) elem incr_count))
              (else (pair (cdr llist) elem result))
        )
    )
)

;make list of pairs for llist.
;pair: (x.y) where y is the count of x in llist
(define (make_pairs llist)
    (if (null? llist) llist
        (let ((first_pair (pair (cdr llist) (car llist)  (cons (car llist) 1)))
              (tail_pairs (make_pairs (remove (car llist) (cdr llist) =)) )
             )
            (cons  first_pair tail_pairs)
        )
    )
)


(define root car)
(define left_tree cadr)
(define right_tree caddr)
(define (make_tree a b c) (list a b c))
(define (leaf? t)
        (and (pair? (root t)) (null? (left_tree t)) (null? (right_tree t)))
)
(define (make_leaf_tree a)
    (if (not (pair? a)) (error "Argument for make_leaf is not pair")
        (make_tree a '() '())
    )
)
(define (value_from_leaf t) (car (root t)))
(define (count_from_leaf t) (cdr (root t)))
(define (make_tree_from_leafs a b) (make_tree (+ (count_from_leaf a) (count_from_leaf b)) a b))
(define (make_tree_from_trees a b) (make_tree (+ (root a) (root b)) a b))
(define (make_tree_from_leaf_and_tree a b) (make_tree (+ (count_from_leaf a ) (root b)) a b))
(define (make_tree_from_tree_and_leaf a b) (make_tree (+ (root a) (count_from_leaf b)) a b))
(define (union_trees a b)
        (cond ((and (leaf? a) (leaf? b)) (make_tree_from_leafs a b))
              ((leaf? a) (make_tree_from_leaf_and_tree a b))
              ((leaf? b) (make_tree_from_tree_and_leaf a b))
              (else (make_tree_from_trees a b))
        )
)
(define (root_value t)
    (if (leaf? t) (count_from_leaf t)
        (root t)
    )
)


(define (eq_pairs? a b)
    (cond ((not (pair? a)) (error "First argument of eq_pair is not pair."))
          ((not (pair? b)) (error "Second argument of eq_pair is not pair."))
          (else (and (= (car a) (car b)) (= (cdr a) (cdr b))))
    )
)
(define (make_list_of_trees pairs)
    (if (null? pairs) pairs
        (cons (make_leaf_tree (car pairs)) (make_list_of_trees (cdr pairs)))
    )
)

(define (get_min_tree trees)
    (define (helper trees result index)
        (cond ((null? trees) result)
              ((< (root_value (car trees)) (root_value (car result))) (helper (cdr trees) (cons (car trees) index) (1+ index)))
              (else (helper (cdr trees) result (1+ index)))
        )
    )
    (if (null? trees) (error "Given empty list for get_min_tree")
        (helper (cdr trees) (cons (car trees) 0) 1)
    )
)

(define (huffman_tree llist)
    (define (helper trees)
        (cond ((null? (cdr trees)) (car trees))
              ((null? (cddr trees)) (union_trees (car trees) (cadr trees)))
              (else (helper (huffman_step trees)))
        )
    )
    (define (huffman_step trees)
        (let* ((min_1 (get_min_tree trees))
               (new_trees_1 (remove_at trees (cdr min_1)))
               (min_2 (get_min_tree new_trees_1))
               (new_trees_2 (remove_at new_trees_1 (cdr min_2)))
              )
              (cons (union_trees (car min_1) (car min_2)) new_trees_2)
        )
    )
    (if (null? llist) '()
        (helper (make_list_of_trees (make_pairs llist)))
    )
)
