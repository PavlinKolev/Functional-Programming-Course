#lang racket

(define (1+ a) (+ a 1))

;removes all elements from llist that are equal to elem, but return the reversed list
(define (remove elem llist cond?)
    (define (remove_help elem llist res)
        (if (null? llist) res
            (if (cond? (car llist) elem) (remove_help elem (cdr llist) res)
                (remove_help elem (cdr llist) (cons (car llist) res))
            )
        )
    )
    (remove_help elem llist '())
)

(define (remove_at llist pos)
    (define (helper llist pos result)
        (cond((null? llist) (error "Index out of range."))
             ((= pos 0) (append result (cdr llist)))
             (else (helper (cdr llist) (- pos 1) (append result (list (car llist)))))
        )
    )
    (helper llist pos '())
)

;creates the pair (elem.count), which represent how many times elem is met in llist
(define (pair llist elem result cond?)
    (let ((incr_count (cons elem (1+ (cdr result))))
         )
        (cond ((null? llist) result)
              ((cond? (car llist) elem) (pair (cdr llist) elem incr_count cond?))
              (else (pair (cdr llist) elem result cond?))
        )
    )
)

;make list of pairs for llist.
;pair: (x.y) where y is the count of x in llist
(define (make_pairs llist cond?)
    (if (null? llist) llist
        (let ((first_pair (pair (cdr llist) (car llist)  (cons (car llist) 1) cond?))
              (tail_pairs (make_pairs (remove (car llist) (cdr llist) cond?) cond?))
             )
            (cons  first_pair tail_pairs)
        )
    )
)


(define root car)
(define left_tree cadr)
(define right_tree caddr)
(define (make_tree a b c) (list a b c))
(define (leaf? t)
        (and (pair? (root t)) (null? (left_tree t)) (null? (right_tree t)))
)
(define (make_leaf_tree a)
    (if (not (pair? a)) (error "Argument for make_leaf is not pair")
        (make_tree a '() '())
    )
)
(define (value_from_leaf t) (car (root t)))
(define (count_from_leaf t) (cdr (root t)))
(define (make_tree_from_leafs a b) (make_tree (+ (count_from_leaf a) (count_from_leaf b)) a b))
(define (make_tree_from_trees a b) (make_tree (+ (root a) (root b)) a b))
(define (make_tree_from_leaf_and_tree a b) (make_tree (+ (count_from_leaf a ) (root b)) a b))
(define (make_tree_from_tree_and_leaf a b) (make_tree (+ (root a) (count_from_leaf b)) a b))
(define (union_trees a b)
        (cond ((and (leaf? a) (leaf? b)) (make_tree_from_leafs a b))
              ((leaf? a) (make_tree_from_leaf_and_tree a b))
              ((leaf? b) (make_tree_from_tree_and_leaf a b))
              (else (make_tree_from_trees a b))
        )
)
(define (root_value t)
    (if (leaf? t) (count_from_leaf t)
        (root t)
    )
)

(define (make_list_of_trees pairs)
    (if (null? pairs) pairs
        (cons (make_leaf_tree (car pairs)) (make_list_of_trees (cdr pairs)))
    )
)

(define (get_min_tree trees)
    (define (helper trees result index)
        (cond ((null? trees) result)
              ((< (root_value (car trees)) (root_value (car result))) (helper (cdr trees) (cons (car trees) index) (1+ index)))
              (else (helper (cdr trees) result (1+ index)))
        )
    )
    (if (null? trees) (error "Given empty list for get_min_tree")
        (helper (cdr trees) (cons (car trees) 0) 1)
    )
)

(define (huffman_tree llist cond?)
    (define (helper trees)
        (cond ((null? (cdr trees)) (car trees))
              ((null? (cddr trees)) (union_trees (car trees) (cadr trees)))
              (else (helper (huffman_step trees)))
        )
    )
    (define (huffman_step trees)
        (let* ((min_1 (get_min_tree trees))
               (new_trees_1 (remove_at trees (cdr min_1)))
               (min_2 (get_min_tree new_trees_1))
               (new_trees_2 (remove_at new_trees_1 (cdr min_2)))
              )
              (cons (union_trees (car min_1) (car min_2)) new_trees_2)
        )
    )
    (if (null? llist) '()
        (helper (make_list_of_trees (make_pairs llist cond?)))
    )
)

(define (encoding_table tree); return list of elements (path.elem) where path is the the path for elem in huffman tree
    (define (helper tree path)
        (cond ((null? tree) "")
              ((leaf? tree) (list (cons path (value_from_leaf tree))))
              (else (append (helper (left_tree tree) (string-append path "0"))
                            (helper (right_tree tree) (string-append path "1"))
                    ))
        )
    )
    (if (leaf? tree) (list (cons "1" (value_from_leaf tree)))
        (helper tree "")
    )
)

(define (encode llist cond?)
    (define (get_code table elem) ;returns the code-string for elem
        (cond ((null? table) (error "No such element in table."))
              ((cond? (cdar table) elem) (caar table))
              (else (get_code (cdr table) elem))
        )
    )
    (define (encode_with_table table llist);returns the wanted encoded string for llist
        (if (null? llist) ""
            (string-append (get_code table (car llist)) (encode_with_table table (cdr llist)))
        )
    )
    (let* ((tree (huffman_tree llist cond?))
           (table (encoding_table tree))
           (encoded (encode_with_table table llist))
        )
        (cons encoded tree)
    )
)


(define (empty_str? str) (equal? str ""))
(define (head_str str) (substring str 0 1))
(define (tail_str str) (substring str 1 (string-length str)))

(define (decode encoded tree)
    (define (one_symbol_list symbol encoded) ;creates list that contains only symbols, with length of llist
        (if (empty_str? encoded) '()
            (cons symbol (one_symbol_list symbol (tail_str encoded)))
        )
    )
    (define (decode_tree encoded tree)
        (define origin_tree tree)
        (define (decode_helper encoded tree)
            (cond ((empty_str? encoded) (if (leaf? tree) (list (value_from_leaf tree)) '()))
                  ((leaf? tree) (cons (value_from_leaf tree) (decode_helper encoded origin_tree)))
                  ((equal? (head_str encoded) "1") (decode_helper (tail_str encoded) (right_tree tree)))
                  (else (decode_helper (tail_str encoded) (left_tree tree))) ; (equal? (head_str encoed) "0")
            )
        )
        (decode_helper encoded tree)
    )
    (cond ((empty_str? encoded) '())
          ((leaf? tree) (one_symbol_list (value_from_leaf tree) encoded))
          (else (decode_tree encoded tree))
    )
)


(define l1 '(1 2 3 4 5 6))
(define l2 '(2 2 2 3 3 2 7 8 9 2))
(define l3 '("FP" "FP" "scheme" "haskell" "FP"))
(define l4 '("Functional" "programming" "scheme"))


(define e1 (encode l1 =))
(define e2 (encode l2 =))
(define e3 (encode l3 equal?))
(define e4 (encode l4 equal?))

(define d1 (decode (car e1) (cdr e1)))
(define d2 (decode (car e2) (cdr e2)))
(define d3 (decode (car e3) (cdr e3)))
(define d4 (decode (car e4) (cdr e4)))
